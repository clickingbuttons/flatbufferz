const std = @import("std");
const fb = @import("flatbufferz");
const writer_mod = @import("writer.zig");
const types = @import("types.zig");

const Allocator = std.mem.Allocator;
const CodeWriter = writer_mod.CodeWriter;
const getBasename = writer_mod.getBasename;
const Options = types.Options;
const BaseType = types.BaseType;
const Schema = types.Schema;
const log = types.log;

fn getOutFilename(allocator: Allocator, opts: Options, name: []const u8) ![]const u8 {
    var res = std.ArrayList(u8).init(allocator);
    var writer = res.writer();
    if (opts.gen_path.len != 0) {
        try writer.writeAll(opts.gen_path);
        try writer.writeByte(std.fs.path.sep);
    }
    for (name) |c| try writer.writeByte(if (c == '.') '/' else c);
    try writer.writeAll(opts.extension);
    return try res.toOwnedSlice();
}

fn isRootTable(typename: []const u8, schema: Schema) bool {
    return if (schema.RootTable()) |root_table|
        std.mem.eql(u8, typename, root_table.Name())
    else
        false;
}

fn createFile(fname: []const u8) !std.fs.File {
    const dir = std.fs.path.dirname(fname).?;
    std.fs.cwd().makePath(dir) catch |e| switch (e) {
        error.PathAlreadyExists => {},
        else => {
            log.err("couldn't make dir {?s}", .{dir});
            return e;
        },
    };

    return try std.fs.cwd().createFile(fname, .{});
}

fn format(allocator: Allocator, fname: []const u8, code: [:0]const u8) ![]const u8 {
    var ast = try std.zig.Ast.parse(allocator, code, .zig);
    defer ast.deinit(allocator);

    if (ast.errors.len > 0) {
        for (ast.errors) |err| {
            var buf = std.ArrayList(u8).init(allocator);
            defer buf.deinit();
            ast.renderError(err, buf.writer()) catch {};
            log.err("formatting {s}: {s}", .{ fname, buf.items });
        }
        return code;
    }

    return try ast.render(allocator);
}

fn writeFiles(
    allocator: Allocator,
    opts: Options,
    schema: Schema,
    bfbs_path: []const u8,
    file_ident: []const u8,
    comptime kind: enum { enum_, object_ },
) !void {
    const len = switch (kind) {
        .enum_ => schema.EnumsLen(),
        .object_ => schema.ObjectsLen(),
    };

    for (0..len) |i| {
        const obj = switch (kind) {
            .enum_ => schema.Enums(i).?,
            .object_ => schema.Objects(i).?,
        };
        const name = obj.Name();
        const decl_file = obj.DeclarationFile();
        const same_file = decl_file.len == 0 or std.mem.eql(u8, decl_file, file_ident);
        if (!same_file) continue;

        var all_code = std.ArrayList(u8).init(allocator);
        defer all_code.deinit();

        {
            var code_writer = CodeWriter.init(allocator, schema, opts);
            defer code_writer.deinit();
            // Write code body first to gather imports
            var code = std.ArrayList(u8).init(allocator);
            defer code.deinit();
            switch (kind) {
                .enum_ => try code_writer.writeEnum(code.writer(), obj),
                .object_ => try code_writer.writeObject(code.writer(), obj),
            }

            {
                var writer = all_code.writer();
                try writer.print(
                    \\//!
                    \\//! generated by flatc-zig
                    \\//! binary:     {s}
                    \\//! file ident: {?s}
                    \\//! typename    {?s}
                    \\//!
                    \\
                , .{ bfbs_path, file_ident, name });
                try code_writer.writeImportDeclarations(writer);

                if (isRootTable(name, schema)) {
                    try writer.print(
                        \\
                        \\pub const file_ident: fb.Builder.Fid = "{s}".*;
                        \\pub const file_ext = "{s}";
                    , .{ schema.FileIdent(), schema.FileExt() });
                    try writer.writeAll("\n\n");
                }
                try writer.writeAll(code.items);
            }
        }

        {
            const fname = try getOutFilename(allocator, opts, name);
            defer allocator.free(fname);
            var file = try createFile(fname);
            defer file.close();

            const formatted_code = try format(allocator, fname, try all_code.toOwnedSliceSentinel(0));
            defer allocator.free(formatted_code);
            try file.writeAll(formatted_code);
        }
    }
}

pub fn codegen(allocator: Allocator, bfbs_path: []const u8, opts: Options) !void {
    const f = try std.fs.cwd().openFile(bfbs_path, .{});
    defer f.close();
    const bfbs = try f.readToEndAlloc(allocator, std.math.maxInt(u16));
    defer allocator.free(bfbs);
    const schema = Schema.GetRootAs(bfbs, 0);

    var fname = getBasename(bfbs_path);
    fname = fname[0 .. fname.len - 5];
    const file_ident = try std.fmt.allocPrint(allocator, "//{s}.fbs", .{fname});
    defer allocator.free(file_ident);
    log.debug("file_ident={s}", .{file_ident});

    try writeFiles(allocator, opts, schema, bfbs_path, file_ident, .enum_);
    try writeFiles(allocator, opts, schema, bfbs_path, file_ident, .object_);
}
